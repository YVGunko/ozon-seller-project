export class OzonApiService {
  constructor(apiKey, clientId) {
    if (!apiKey || !clientId) {
      throw new Error('OZON API credentials are required');
    }

    this.apiKey = apiKey;
    this.clientId = clientId;
    this.baseURL = 'https://api-seller.ozon.ru';
  }

  async makeRequest(endpoint, body = {}) {
    console.log(`ðŸ”„ Making request to: ${endpoint}`);
    console.log('ðŸ“¦ Request body:', JSON.stringify(body, null, 2));

    try {
      const response = await fetch(`${this.baseURL}${endpoint}`, {
        method: 'POST',
        headers: {
          'Client-Id': this.clientId,
          'Api-Key': this.apiKey,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(body),
      });

      console.log(`ðŸ“Š Response status: ${response.status}`);

      if (!response.ok) {
        const errorText = await response.text();
        console.error(`âŒ API Error ${response.status}:`, errorText);
        throw new Error(`OZON API Error: ${response.status} - ${errorText}`);
      }

      const data = await response.json();
      console.log('âœ… Request successful');
      return data;
    } catch (error) {
      console.error('âŒ Fetch error:', error.message);
      throw error;
    }
  }

  // ÐœÐµÑ‚Ð¾Ð´ Ð´Ð»Ñ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð·Ð°ÐºÐ°Ð·Ð¾Ð² (ÐµÑÐ»Ð¸ Ð½ÑƒÐ¶ÐµÐ½)
  async getOrders() {
    return this.makeRequest('/v2/order/list', {
      filter: {},
      limit: 10,
      sort_by: 'created_at',
      sort_order: 'desc'
    });
  }

  // ÐÐžÐ’Ð«Ð™ ÐœÐ•Ð¢ÐžÐ”: ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ ÑÐ¿Ð¸ÑÐºÐ° Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ð¾Ð²
  async getProducts(options = {}) {
    const body = {
      filter: {
        offer_id: options.filter?.offer_id || [], // Should be an array
        product_id: options.filter?.product_ids || [],
        visibility: options.filter?.visibility || "ALL"
      },
      last_id: options.last_id || "",
      limit: options.limit || 100
    };
    console.log('Sending request body to OZON:', JSON.stringify(body, null, 2));
    return this.makeRequest('/v3/product/list', body);
  }

  async getProductAttributes(offerId) {
    const body = {
      filter: {
        offer_id: [offerId] // ÐœÐ°ÑÑÐ¸Ð² Ñ Ð¾Ð´Ð½Ð¸Ð¼ offer_id
      },
      limit: 1
    };

    console.log('ðŸ“‹ Fetching attributes for offer:', offerId);
    return this.makeRequest('/v4/product/info/attributes', body);
  }

  async copyProduct(sourceOfferId, newOfferId, modifications = {}) {
    console.log(`ðŸ“‹ Copying product from ${sourceOfferId} to ${newOfferId}`);

    try {
      // 1. ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¸ÑÑ…Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ñ‚Ð¾Ð²Ð°Ñ€Ð°
      const sourceAttributes = await this.getProductAttributes(sourceOfferId);

      if (!sourceAttributes.result || sourceAttributes.result.length === 0) {
        throw new Error('Source product not found');
      }

      const sourceProduct = sourceAttributes.result[0];

      // 2. ÐŸÐ¾Ð´Ð³Ð¾Ñ‚Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð´Ð»Ñ Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ñ‚Ð¾Ð²Ð°Ñ€Ð°
      const newProductData = this.prepareProductData(sourceProduct, newOfferId, modifications);

      // 3. Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ Ð½Ð¾Ð²Ñ‹Ð¹ Ñ‚Ð¾Ð²Ð°Ñ€
      return await this.createProduct(newProductData);
    } catch (error) {
      console.error('Error copying product:', error);
      throw error;
    }
  }

  async createProduct(productData) {
    const body = {
      items: [productData]
    };

    console.log('ðŸ†• Creating new product:', JSON.stringify(body, null, 2));
    return this.makeRequest('/v3/product/import', body);
  }

  prepareProductData(sourceProduct, newOfferId, modifications) {
    // Ð‘Ð°Ð·Ð¾Ð²Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¸Ð· Ð¸ÑÑ…Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ñ‚Ð¾Ð²Ð°Ñ€Ð°
    const newProduct = {
      offer_id: newOfferId,
      name: modifications.name || sourceProduct.name,
      category_id: sourceProduct.description_category_id,
      price: modifications.price || "0",
      old_price: modifications.old_price || "0",
      premium_price: modifications.premium_price || "0",
      vat: "0"
    };

    // ÐžÐ±Ñ€Ð°Ð±Ð°Ñ‚Ñ‹Ð²Ð°ÐµÐ¼ Ð°Ñ‚Ñ€Ð¸Ð±ÑƒÑ‚Ñ‹
    if (sourceProduct.attributes) {
      newProduct.attributes = this.processAttributes(
        sourceProduct.attributes,
        modifications
      );
    }

    // ÐžÐ±Ñ€Ð°Ð±Ð°Ñ‚Ñ‹Ð²Ð°ÐµÐ¼ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ
    if (sourceProduct.images && sourceProduct.images.length > 0) {
      newProduct.images = sourceProduct.images.map((image, index) => ({
        file_name: image,
        default: index === 0
      }));
    }

    // Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ñ€Ð°Ð·Ð¼ÐµÑ€Ñ‹ Ð¸ Ð²ÐµÑ, ÐµÑÐ»Ð¸ ÐµÑÑ‚ÑŒ
    if (sourceProduct.depth) newProduct.depth = sourceProduct.depth;
    if (sourceProduct.height) newProduct.height = sourceProduct.height;
    if (sourceProduct.width) newProduct.width = sourceProduct.width;
    if (sourceProduct.weight) newProduct.weight = sourceProduct.weight;
    if (sourceProduct.dimension_unit) newProduct.dimension_unit = sourceProduct.dimension_unit;
    if (sourceProduct.weight_unit) newProduct.weight_unit = sourceProduct.weight_unit;

    // ÐŸÑ€Ð¸Ð¼ÐµÐ½ÑÐµÐ¼ Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ Ð¼Ð¾Ð´Ð¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸Ð¸
    Object.keys(modifications).forEach(key => {
      if (!['name', 'price', 'old_price', 'premium_price'].includes(key)) {
        newProduct[key] = modifications[key];
      }
    });

    return newProduct;
  }

  processAttributes(attributes, modifications) {
    return attributes.map(attr => {
      const attributeCopy = { ...attr };

      // ÐŸÑ€Ð¸Ð¼ÐµÐ½ÑÐµÐ¼ Ð¼Ð¾Ð´Ð¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸Ð¸ Ðº Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð½Ñ‹Ð¼ Ð°Ñ‚Ñ€Ð¸Ð±ÑƒÑ‚Ð°Ð¼
      if (modifications.color && this.isColorAttribute(attr)) {
        attributeCopy.values = [{ value: modifications.color }];
      }

      if (modifications.description && this.isDescriptionAttribute(attr)) {
        attributeCopy.values = [{ value: modifications.description }];
      }

      // Ð”Ð¾Ð±Ð°Ð²ÑŒÑ‚Ðµ Ð´Ñ€ÑƒÐ³Ð¸Ðµ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ Ð°Ñ‚Ñ€Ð¸Ð±ÑƒÑ‚Ð¾Ð² Ð¿Ð¾ Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ð¾ÑÑ‚Ð¸

      return attributeCopy;
    });
  }

  isColorAttribute(attr) {
    // ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÐ¼, ÑÐ²Ð»ÑÐµÑ‚ÑÑ Ð»Ð¸ Ð°Ñ‚Ñ€Ð¸Ð±ÑƒÑ‚ Ñ†Ð²ÐµÑ‚Ð¾Ð¼ (Ð·Ð°Ð²Ð¸ÑÐ¸Ñ‚ Ð¾Ñ‚ Ð²Ð°ÑˆÐµÐ¹ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ñ‹ Ð°Ñ‚Ñ€Ð¸Ð±ÑƒÑ‚Ð¾Ð²)
    const colorKeywords = ['color', 'Ñ†Ð²ÐµÑ‚', 'colore', 'farbe'];
    return colorKeywords.some(keyword =>
      attr.id.toString().toLowerCase().includes(keyword) ||
      (attr.values && attr.values.some(v =>
        v.value && v.value.toLowerCase().includes(keyword)
      ))
    );
  }

  isDescriptionAttribute(attr) {
    // ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÐ¼, ÑÐ²Ð»ÑÐµÑ‚ÑÑ Ð»Ð¸ Ð°Ñ‚Ñ€Ð¸Ð±ÑƒÑ‚ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸ÐµÐ¼
    const descriptionKeywords = ['description', 'Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ', 'beschreibung'];
    return descriptionKeywords.some(keyword =>
      attr.id.toString().toLowerCase().includes(keyword)
    );
  }
  // Ð£Ð¿Ñ€Ð¾Ñ‰ÐµÐ½Ð½Ñ‹Ð¹ Ð¼ÐµÑ‚Ð¾Ð´ Ð´Ð»Ñ Ð±Ñ‹ÑÑ‚Ñ€Ð¾Ð³Ð¾ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ð¾Ð²
  async getSimpleProducts(limit = 10) {
    return this.getProducts({
      filter: {
        visibility: "ALL"
      },
      limit: limit
    });
  }

  // ÐœÐµÑ‚Ð¾Ð´ Ð´Ð»Ñ Ð¼Ð°ÑÑÐ¾Ð²Ð¾Ð³Ð¾ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ Ñ‚Ð¾Ð²Ð°Ñ€Ð¾Ð²
  async createProductsBatch(products) {
    const body = {
      items: products
    };

    console.log('ðŸ†• Creating products batch:', JSON.stringify(body, null, 2));
    return this.makeRequest('/v2/product/import', body);
  }

  // ÐœÐµÑ‚Ð¾Ð´ Ð´Ð»Ñ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ñ‚Ð¾Ð²Ð°Ñ€Ð°
  async createProduct(productData) {
    const body = {
      items: [productData]
    };

    console.log('ðŸ†• Creating product:', JSON.stringify(body, null, 2));
    return this.makeRequest('/v2/product/import', body);
  }

  // Ð’ÑÐ¿Ð¾Ð¼Ð¾Ð³Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹ Ð¼ÐµÑ‚Ð¾Ð´ Ð´Ð»Ñ Ñ„Ð¾Ñ€Ð¼Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ñ‚Ð¾Ð²Ð°Ñ€Ð°
  prepareProductFromTemplate(baseData, excelRow, fieldMappings) {
    const product = {
      offer_id: this.generateFieldValue('offer_id', baseData, excelRow, fieldMappings),
      name: this.generateFieldValue('name', baseData, excelRow, fieldMappings),
      category_id: baseData.category_id,
      price: baseData.price || "0",
      old_price: baseData.old_price || "0",
      vat: baseData.vat || "0",
      attributes: []
    };

    // Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ð°Ñ‚Ñ€Ð¸Ð±ÑƒÑ‚Ñ‹ Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ fieldMappings
    Object.keys(fieldMappings).forEach(fieldKey => {
      const mapping = fieldMappings[fieldKey];
      if (mapping.attributeId && mapping.enabled) {
        const value = this.generateFieldValue(fieldKey, baseData, excelRow, fieldMappings);
        if (value) {
          product.attributes.push({
            id: mapping.attributeId,
            value: value
          });
        }
      }
    });

    return product;
  }

  generateFieldValue(fieldKey, baseData, excelRow, fieldMappings) {
    const mapping = fieldMappings[fieldKey];
    if (!mapping) return '';

    let value = mapping.template;

    // Ð—Ð°Ð¼ÐµÐ½ÑÐµÐ¼ Ð¿Ð»ÐµÐ¹ÑÑ…Ð¾Ð»Ð´ÐµÑ€Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ð¼Ð¸ Ð¸Ð· Excel
    if (value.includes('{colour_code}') && excelRow.colourCode) {
      value = value.replace(/{colour_code}/g, excelRow.colourCode);
    }
    if (value.includes('{colour_name}') && excelRow.colourName) {
      value = value.replace(/{colour_name}/g, excelRow.colourName);
    }
    if (value.includes('{car_brand}') && excelRow.carBrand) {
      value = value.replace(/{car_brand}/g, excelRow.carBrand);
    }
    if (value.includes('{row_index}')) {
      value = value.replace(/{row_index}/g, excelRow.index + 1);
    }

    return value;
  }

  // ÐœÐµÑ‚Ð¾Ð´ Ð´Ð»Ñ Ð¿Ð°Ñ€ÑÐ¸Ð½Ð³Ð° Excel Ñ„Ð°Ð¹Ð»Ð°
  async parseExcelFile(file) {
    const ExcelJS = require('exceljs');
    const workbook = new ExcelJS.Workbook();
    await workbook.xlsx.load(file); // 'file' should be a Buffer

    const worksheet = workbook.worksheets[0]; // Get first sheet
    const jsonData = [];

    // Process rows. Note: ExcelJS rows are 1-indexed.
    worksheet.eachRow((row, rowNumber) => {
      if (rowNumber === 1) return; // Skip header row if your file has one

      // Access cell values by column number (1-indexed)
      const processedRow = {
        index: rowNumber - 1, // Adjust for zero-based index
        colourCode: row.getCell(2).value?.toString(), // Assuming Colour Code is col A
        colourName: row.getCell(3).value?.toString(), // Assuming Colour Name is col B
        carBrand: row.getCell(5).value?.toString(),   // Assuming Car Brand is col C
        rawData: row.values // Gets all values as an array
      };

      // Only push rows that have data
      if (processedRow.colourCode) {
        jsonData.push(processedRow);
      }
    });

    return jsonData;
  }

  findColumnValue(row, possibleColumnNames) {
    for (const colName of possibleColumnNames) {
      if (row[colName] !== undefined) {
        return row[colName];
      }
    }
    return '';
  }
}